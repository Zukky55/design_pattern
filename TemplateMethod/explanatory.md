# TemplateMethod

## Overview
---
処理の流れをテンプレートとして用意し、継承先で意識しなくて良くなるパターン

ロジックの大枠(何をどの順序で呼び出すか等)をスーパークラスで実装する事で継承先でロジックの大枠を意識することなく、継承先で実装すべき特殊化された処理の実装に集中して取り組める。

イメージは「バイトの新人でもオペレーションシートがあれば正しく作業できるよね。後よろしく」的な感じ。


## Merit
---
1. 大まかな流れをスーパークラスで定義すれば、継承先ではそれぞれの関数の処理を実装すればいいだけになり、全体の流れを設計実装しなくてもよい。
1. 単純にコード量減る。
1. 可読性up
1. ロジックの修正はスーパークラスのみかえれば全てに適応させられる
1. 上記によりメンテナンス性up

## Demerit
---
1. スーパークラスで定義したロジックを個別に変えたい場合は使えない。
2. スーパークラスで詳細にロジックを実装しすぎると継承先での拡張性が低くなる

## 他のデザインパターンとの関係性
---
- singleton
- mvc
- factory
等、処理のコアな部分をテンプレートとして実装すれば、毎回パターンの土台を実装せずに済む。

## SOLID原則との関係性
---
### - Single Responsibility Principle
満たしている。

- ロジックの大枠を定義するという単一の役割において満たしている

### - Open Closed Principle
満たしている。
- スーパークラスで定義されたテンプレートは拡張できる。
- テンプレート自体を変えたい場合は継承元のみ変えればよい。
- 継承先で個別にフロー自体を変えたい要件に対しては工夫をするか、他のパターンを採用しなければならない。

### - Substitution Principle
満たしている。
- 継承元で定義された関数がabstractの場合そもそも実行できないが、virtualで定義している場合可能。

### - Interface Segregation Principle
満たしている。
- 継承元ではテンプレートとして必ず使用するインターフェースのみ実装してあるはず。

### - Dependency Inversion Principle
満たしている。
- 継承元において、継承先に依存していない。